from typing import Union

import discord
from discord import Option
from dotenv import load_dotenv
import os
import logging

load_dotenv()
logging.basicConfig()
logger = logging.getLogger("tkqa-bot")
logger.setLevel(logging.INFO)
bot = discord.Bot()

guild = 976345115826212884
qa_channel = 976356366316875807
helper_role = 976669617097437208
embed_thumbnail_url = "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/" \
                      "Icon-round-Question_mark.svg/2048px-Icon-round-Question_mark.svg.png"


def gen_embed(qn: str, author: Union[discord.User, discord.Member],
              helper_role_id=helper_role) -> discord.Embed:
    embed = discord.Embed(title="QA Thread",
                          description=f"Please respond in the thread directly.\n"
                                      f"{author.mention}, please provide additional context if needed.\n"
                                      f"<@{helper_role_id}>, please provide assistance if possible",
                          color=0x2bff00)
    avatar_url = author.default_avatar.url
    if author.avatar:
        avatar_url = author.avatar.url
    embed.set_author(name=str(author),
                     icon_url=avatar_url)
    embed.set_thumbnail(
        url=embed_thumbnail_url)
    embed.add_field(name="Question", value=qn, inline=False)
    embed.set_footer(text="Generated by tinkerqa-discord v0.1.0")
    return embed


@bot.event
async def on_ready():
    logger.info(f'Logged in as {bot.user.name}')


@bot.slash_command(guild_ids=[guild], name="ask",
                   description="Creates a new thread in the #qa channel")
async def create(ctx: discord.commands.context.ApplicationContext,
                 question: Option(str, "What is your question?", required=True, default='')):
    if not question:
        await ctx.respond("Please try again, with an ACTUAL question")
        return
    user_response = await ctx.respond("Please wait, creating the thread now")
    with ctx.typing():
        embed = gen_embed(question, ctx.author)
        # note: very fragile. needs to be improved
        msg = await bot.get_channel(qa_channel).send(f"{ctx.author.mention}", embed=embed)
        thread = await msg.create_thread(name=question)
        logger.info(f"Created thread {thread.id}")
        await user_response.edit_original_message(content=f"Please see: {thread.jump_url}")


async def get_first_message(channel: discord.Thread) -> discord.Message:
    async for msg in channel.history(limit=1, oldest_first=True):
        return msg


@bot.slash_command(guild_ids=[guild], name="close", description="Closes the current thread")
async def close(ctx: discord.commands.context.ApplicationContext):
    if not isinstance(ctx.channel, discord.Thread):
        await ctx.respond("This command can only be ran inside a thread")
        return
    thread: discord.Thread = ctx.channel
    if thread.locked:
        await ctx.respond("This command cannot be used inside a locked thread")
        return
    # note: this hack is needed because it turns out that mentions don't get retrieved
    # not sure why
    first_msg = await get_first_message(thread)
    if not first_msg.system_content:
        await ctx.respond("Internal error, please contact devs. Error code: empty-content")
        return
    # trial_2 = await thread.fetch_message(first_msg.id)
    contents = first_msg.system_content
    contents = contents.replace("<@", "").replace(">", "")
    try:
        int(contents)
    except ValueError:
        await ctx.respond("Internal error, please contact devs. Error code: no ping")
        return
    if int(contents) == int(ctx.author.id) or ctx.author.guild_permissions.manage_threads:
        if ctx.author.guild_permissions.manage_threads:
            await ctx.respond("Thread closed by moderator")
        else:
            await ctx.respond("Thread closed by OP")
        await thread.archive(locked=True)
    else:
        await ctx.respond("You do not have permission to close this thread")


# @bot.slash_command(guild_ids=[guild], name="clear_channel",
#                    description="Deletes all the messages present in the channel")
# async def clear_channel(ctx: discord.commands.context.ApplicationContext):
#     if isinstance(ctx.channel, discord.TextChannel):
#         chan: discord.TextChannel = ctx.channel
#         await chan.delete_messages([m async for m in chan.history(limit=200)])
#         await ctx.respond("Done.")
#     else:
#         await ctx.respond("Can't delete")


if __name__ == "__main__":
    bot.run(os.environ.get('DISCORD_TOKEN'))
