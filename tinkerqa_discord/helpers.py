from typing import Union

import discord

from tinkerqa_discord.exceptions import HackyException


async def get_first_message(channel: discord.Thread) -> discord.Message:
    """
    Retrieves the first message in a thread
    :param channel: The thread to retrieve the first message from
    :return: The first message
    """
    async for msg in channel.history(limit=1, oldest_first=True):
        return msg


def gen_embed(qn: str, author: Union[discord.User, discord.Member],
              helper_role_ping: discord.Role) -> discord.Embed:
    """
    Generates the embed template for the message and thread to be posted in the Q&A channel
    :param qn: The question
    :param author: The author of the question
    :param helper_role_ping: Role of helpers to ping
    :return: The embed template
    """
    embed = discord.Embed(title="QA Thread",
                          description=f"{author.mention} asked: *{qn}*"
                                      f"Please respond in the thread directly.\n"
                                      f"{author.mention}, please provide additional context if needed.\n"
                                      f"\n",
                                      # f"{helper_role_ping.mention}, please provide assistance if possible",
                          color=0x2bff00)
    embed_thumbnail_url = "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/" \
                          "Icon-round-Question_mark.svg/2048px-Icon-round-Question_mark.svg.png"
    avatar_url = author.default_avatar.url
    if author.avatar:
        avatar_url = author.avatar.url
    embed.set_author(name=str(author),
                     icon_url=avatar_url)
    embed.set_thumbnail(
        url=embed_thumbnail_url)
    embed.add_field(name="Question", value=qn, inline=False)
    embed.set_footer(text="Generated by tinkerqa-discord")
    return embed


async def hacky_get_thread_starter_user_id(thread: discord.Thread) -> int:
    """
    This function is a hack to grab the "author" of the thread.
    Note this is extremely fragile and very highly dependent on how the message was sent.

    This hack is needed because the first_msg does NOT contain mentions, even if I
    explicitly mention the author. As such, I am forced to parse it as such

    :param thread: The thread
    :return: The "author's" user ID
    :raises HackyException: If the message is empty
    :raises ValueError: If the message is in the wrong format
    """
    first_msg = await get_first_message(thread)
    if not first_msg.system_content:
        raise HackyException("Empty content")
    contents = first_msg.system_content
    contents = contents.replace("<@", "").replace(">", "")  # awful hack
    return int(contents)
